<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Spell Snake - Learn Names</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #2c3e50;
            --panel-bg: #34495e;
            --accent-color: #f1c40f;
            --text-color: #ecf0f1;
            --btn-primary: #e67e22;
            --btn-secondary: #2ecc71;
            --snake-head: #2ecc71;
            /* Green Head */
            --snake-correct: #f1c40f;
            /* Yellow Body */
            --snake-wrong: #e74c3c;
            /* Red Body */
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Fredoka', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            overscroll-behavior: none;
            /* Prevent pull-to-refresh */
        }

        /* --- Start Screen UI --- */
        #startScreen {
            width: 100%;
            max-width: 600px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            animation: fadeIn 0.5s ease-out;
            overflow-y: auto;
            max-height: 100vh;
        }

        h1 {
            font-size: 3rem;
            color: var(--accent-color);
            text-shadow: 2px 2px 0px #000;
            margin: 10px 0;
            text-align: center;
        }

        .card {
            background: var(--panel-bg);
            border-radius: 20px;
            padding: 25px;
            width: 100%;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        input[type="text"] {
            flex: 1;
            padding: 15px;
            font-size: 1.2rem;
            border: none;
            border-radius: 12px;
            background: #ecf0f1;
            color: #2c3e50;
            font-family: inherit;
            font-weight: 600;
            text-transform: uppercase;
        }

        button {
            border: none;
            border-radius: 12px;
            padding: 15px 25px;
            font-family: inherit;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            transition: transform 0.1s, filter 0.1s;
            color: white;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        .btn-add {
            background-color: var(--btn-secondary);
        }

        .btn-start {
            background-color: var(--btn-primary);
            width: 100%;
            font-size: 1.5rem;
            margin-top: 10px;
        }

        .btn-start:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .quick-adds {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .tag-btn {
            background-color: #9b59b6;
            padding: 8px 16px;
            font-size: 0.9rem;
        }

        .names-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            min-height: 50px;
            align-content: flex-start;
        }

        .name-chip {
            background-color: var(--accent-color);
            color: #2c3e50;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .delete-chip {
            background: rgba(0, 0, 0, 0.1);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
        }

        /* --- Game Screen UI --- */
        #gameScreen {
            display: none;
            width: 100%;
            height: 100vh;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            position: relative;
        }

        .hud {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px 20px;
            border-radius: 15px;
            margin-bottom: 10px;
        }

        .hud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .hud-label {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .hud-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--accent-color);
        }

        .target-word {
            font-size: 2rem;
            letter-spacing: 5px;
            font-weight: 600;
            margin: 5px 0;
            text-align: center;
            height: 40px;
        }

        .letter-slot {
            display: inline-block;
            color: #7f8c8d;
            transition: color 0.3s;
        }

        .letter-slot.collected {
            color: var(--accent-color);
            text-shadow: 0 0 10px var(--accent-color);
        }

        #gameCanvas {
            background: #1a252f;
            border-radius: 10px;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            max-height: 55vh;
            /* Slightly more space */
            touch-action: none;
            /* Critical for swipe */
        }

        /* --- Controls --- */
        .controls-area {
            width: 100%;
            max-width: 400px;
            height: 200px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .dpad-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: white;
            cursor: pointer;
            user-select: none;
        }

        .dpad-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        .dpad-up {
            grid-column: 2;
            grid-row: 1;
        }

        .dpad-left {
            grid-column: 1;
            grid-row: 2;
        }

        .dpad-down {
            grid-column: 2;
            grid-row: 2;
        }

        .dpad-right {
            grid-column: 3;
            grid-row: 2;
        }

        /* --- Modals --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: white;
            color: #2c3e50;
            padding: 30px;
            border-radius: 25px;
            text-align: center;
            max-width: 90%;
            width: 400px;
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .modal-title {
            font-size: 2rem;
            margin-bottom: 10px;
            color: #e67e22;
        }

        .modal-msg {
            font-size: 1.2rem;
            margin-bottom: 25px;
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>

<body>

    <!-- Start Screen -->
    <div id="startScreen">
        <h1>üêç Spell Snake</h1>

        <div class="card">
            <h3>Who are we spelling today?</h3>
            <div class="input-group">
                <input type="text" id="nameInput" placeholder="Enter Name (e.g. MOM)" maxlength="12">
                <button class="btn-add" onclick="addName()">ADD</button>
            </div>

            <div class="quick-adds">
                <button class="tag-btn" onclick="quickAdd('MOM')">MOM</button>
                <button class="tag-btn" onclick="quickAdd('DAD')">DAD</button>
                <button class="tag-btn" onclick="quickAdd('GRANDMA')">GRANDMA</button>
                <button class="tag-btn" onclick="quickAdd('GRANDPA')">GRANDPA</button>
                <button class="tag-btn" onclick="quickAdd('KRUPESH')">KRUPESH</button>
                <button class="tag-btn" onclick="quickAdd('SHIRJA')">SHIRJA</button>
            </div>

            <div class="names-list" id="namesList">
                <!-- Chips go here -->
            </div>
        </div>

        <button class="btn-start" id="startBtn" onclick="startGame()" disabled>START GAME</button>

        <p style="opacity: 0.6; margin-top: 20px; font-size: 0.9rem;">
            Tip: Eat the correct letters to spell the name! Wrong letters turn RED.
        </p>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen">
        <div class="hud">
            <div class="hud-item">
                <span class="hud-label">SCORE</span>
                <span class="hud-value" id="scoreDisplay">0</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">LIVES</span>
                <span class="hud-value" id="livesDisplay">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
            </div>
        </div>

        <div class="target-word" id="wordDisplay">
            <!-- Letters go here -->
        </div>

        <canvas id="gameCanvas"></canvas>

        <div class="controls-area">
            <div class="dpad-btn dpad-up">‚¨ÜÔ∏è</div>
            <div class="dpad-btn dpad-left">‚¨ÖÔ∏è</div>
            <div class="dpad-btn dpad-down">‚¨áÔ∏è</div>
            <div class="dpad-btn dpad-right">‚û°Ô∏è</div>
        </div>
    </div>

    <!-- Victory Modal -->
    <div id="victoryModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title">üéâ Amazing!</div>
            <div class="modal-msg" id="victoryMsg">You spelled it!</div>
            <button class="btn-start" onclick="nextLevel()">Next Name ‚û°Ô∏è</button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title">üí• Oh no!</div>
            <div class="modal-msg">Watch out for walls!</div>
            <button class="btn-add" onclick="retryLevel()" style="width:100%; margin-bottom:10px;">Try Again üîÑ</button>
            <button class="btn-add" onclick="showStartScreen()" style="width:100%; background:#e74c3c;">Main Menu
                üè†</button>
        </div>
    </div>

    <script>
        // --- Game State ---
        let names = [];
        let currentNameIndex = 0;
        let currentName = "";
        let collectedCount = 0;
        let score = 0;
        let lives = 3;
        let gameLoop = null;
        let isPaused = false;

        // --- Snake & Grid ---
        const gridSize = 20;
        let tileCountX = 20;
        let tileCountY = 20;

        // Snake segments: {x, y, char, color}
        // snake[0] is HEAD
        let snake = [];
        let velocity = { x: 0, y: 0 };
        let nextVelocity = { x: 0, y: 0 };
        let gulpTimer = 0;

        // --- Items ---
        let targetLetterItem = null;
        let decoyItems = [];

        // --- Audio Context ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let musicNode = null;

        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nameInput = document.getElementById('nameInput');

        // --- Initialization ---
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            document.addEventListener('keydown', handleKeyInput);
            setupControls();
            setupSwipe();
        }

        function setupControls() {
            const directions = ['UP', 'LEFT', 'DOWN', 'RIGHT'];
            directions.forEach(dir => {
                const btn = document.querySelector(`.dpad-${dir.toLowerCase()}`);
                if (btn) {
                    const handler = (e) => {
                        e.preventDefault();
                        handleInput(dir);
                    };
                    btn.addEventListener('touchstart', handler, { passive: false });
                    btn.addEventListener('mousedown', handler);
                }
            });

            // Removed blanket preventDefault on all buttons to allow clicks on Start/Add buttons
        }

        function setupSwipe() {
            let touchStartX = 0;
            let touchStartY = 0;

            canvas.addEventListener('touchstart', function (e) {
                e.preventDefault(); // Prevent scroll
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: false });

            canvas.addEventListener('touchend', function (e) {
                e.preventDefault();
                let touchEndX = e.changedTouches[0].screenX;
                let touchEndY = e.changedTouches[0].screenY;
                handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
            }, { passive: false });
        }

        function resizeCanvas() {
            const hudHeight = 80;
            const controlsHeight = 220;
            const wordHeight = 50;
            const padding = 40;

            const availableHeight = window.innerHeight - hudHeight - controlsHeight - wordHeight - padding;
            const availableWidth = window.innerWidth - 20;

            const cellSize = Math.floor(Math.min(availableWidth / 12, availableHeight / 12));
            const finalCellSize = Math.max(cellSize, 15);

            const cols = Math.floor(availableWidth / finalCellSize);
            const rows = Math.floor(availableHeight / finalCellSize);

            tileCountX = Math.max(cols, 10);
            tileCountY = Math.max(rows, 10);

            canvas.width = tileCountX * finalCellSize;
            canvas.height = tileCountY * finalCellSize;
            canvas.cellSize = finalCellSize;
        }

        // --- UI Functions ---
        function addName() {
            const val = nameInput.value.trim().toUpperCase();
            if (!val) return;
            if (names.includes(val)) {
                alert("Name already added!");
                return;
            }
            names.push(val);
            nameInput.value = "";
            renderNamesList();
        }

        function quickAdd(val) {
            if (names.includes(val)) return;
            names.push(val);
            renderNamesList();
        }

        function removeName(index) {
            names.splice(index, 1);
            renderNamesList();
        }

        function renderNamesList() {
            const list = document.getElementById('namesList');
            list.innerHTML = "";
            names.forEach((n, i) => {
                const chip = document.createElement('div');
                chip.className = 'name-chip';
                chip.innerHTML = `${n} <div class="delete-chip" onclick="removeName(${i})">‚úï</div>`;
                list.appendChild(chip);
            });
            document.getElementById('startBtn').disabled = names.length === 0;
        }

        function showStartScreen() {
            stopMusic();
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('victoryModal').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }

        // --- Game Logic ---
        function startGame() {
            if (names.length === 0) return;

            if (!audioCtx) audioCtx = new AudioContext();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            playMusic();

            currentNameIndex = 0;
            score = 0;
            lives = 3;

            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'flex';
            resizeCanvas();
            startLevel();
        }

        function startLevel() {
            currentName = names[currentNameIndex];
            collectedCount = 0;

            const startX = Math.floor(tileCountX / 2);
            const startY = Math.floor(tileCountY / 2);

            // Initial snake: Just head
            snake = [
                { x: startX, y: startY, char: '', color: 'head' }
            ];

            velocity = { x: 0, y: -1 };
            nextVelocity = { x: 0, y: -1 };

            decoyItems = [];
            spawnTarget();
            updateHUD();
            document.getElementById('victoryModal').style.display = 'none';

            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, 350); // Slow speed for kids
        }

        function spawnTarget() {
            // Target letter
            const letter = currentName[collectedCount];
            targetLetterItem = findEmptySpot();
            targetLetterItem.char = letter;
            targetLetterItem.type = 'target';

            // Decoys
            const decoyCount = 2; // Keep it simple
            decoyItems = [];
            const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

            for (let i = 0; i < decoyCount; i++) {
                let spot = findEmptySpot();
                let char = alphabet[Math.floor(Math.random() * alphabet.length)];
                while (char === letter) {
                    char = alphabet[Math.floor(Math.random() * alphabet.length)];
                }
                spot.char = char;
                spot.type = 'decoy';
                decoyItems.push(spot);
            }
        }

        function findEmptySpot() {
            let spot;
            while (true) {
                spot = {
                    x: Math.floor(Math.random() * tileCountX),
                    y: Math.floor(Math.random() * tileCountY)
                };
                let onSnake = snake.some(s => s.x === spot.x && s.y === spot.y);
                let onTarget = targetLetterItem && targetLetterItem.x === spot.x && targetLetterItem.y === spot.y;
                let onDecoy = decoyItems.some(d => d.x === spot.x && d.y === spot.y);
                if (!onSnake && !onTarget && !onDecoy) break;
            }
            return spot;
        }

        function update() {
            if (isPaused) return;

            velocity = nextVelocity;
            const head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y, char: '', color: 'head' };

            // Wall Collision
            if (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY) {
                handleCrash();
                return;
            }

            // Self Collision
            if (snake.some(s => s.x === head.x && s.y === head.y)) {
                handleCrash();
                return;
            }

            // Add new head
            snake.unshift(head);

            // Check Items
            let eatenItem = null;
            let isCorrect = false;

            // Check Target
            if (head.x === targetLetterItem.x && head.y === targetLetterItem.y) {
                eatenItem = targetLetterItem;
                isCorrect = true;
            }
            // Check Decoys
            else {
                const decoyIdx = decoyItems.findIndex(d => d.x === head.x && d.y === head.y);
                if (decoyIdx !== -1) {
                    eatenItem = decoyItems[decoyIdx];
                    isCorrect = false;
                }
            }

            if (eatenItem) {
                // EAT LOGIC
                // The segment BEHIND the head (snake[1]) takes on the eaten properties
                // Because snake[0] is the NEW head
                snake[1].char = eatenItem.char;
                snake[1].color = isCorrect ? 'correct' : 'wrong';

                gulpTimer = 5;

                if (isCorrect) {
                    playSound('collect');
                    score += 10;
                    collectedCount++;
                    if (collectedCount >= currentName.length) {
                        handleWin();
                        return;
                    }
                } else {
                    playSound('crash'); // Wrong letter sound
                    // Reset progress on wrong letter!
                    collectedCount = 0;
                    // Don't lose life, just add red segment
                }

                spawnTarget(); // Respawn items
                updateHUD();

                // Don't pop! Snake grows.
            } else {
                // Didn't eat, move tail
                // Standard snake: pop the last element
                snake.pop();

                // If we didn't eat, snake[1] (old head) needs to become a body part
                // We assign default body color to it if it doesn't have one
                if (snake.length > 1) {
                    if (!snake[1].char) {
                        snake[1].color = 'body';
                    }
                }
            }
            draw();
        }



        function draw() {
            ctx.fillStyle = '#1a252f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const cs = canvas.cellSize;

            // Draw Grid (Subtle)
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= tileCountX; x++) {
                ctx.beginPath();
                ctx.moveTo(x * cs, 0);
                ctx.lineTo(x * cs, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= tileCountY; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * cs);
                ctx.lineTo(canvas.width, y * cs);
                ctx.stroke();
            }

            // Snake
            snake.forEach((seg, i) => {
                let color = '#2ecc71'; // Green Head
                if (i > 0) {
                    if (seg.color === 'correct') color = '#f1c40f'; // Yellow
                    else if (seg.color === 'wrong') color = '#e74c3c'; // Red
                    else color = '#27ae60'; // Body default
                }

                ctx.fillStyle = color;

                // Gulp
                let size = cs;
                let offset = 0;
                if (i === 0 && gulpTimer > 0) {
                    size = cs * 1.3;
                    offset = (cs - size) / 2;
                    gulpTimer--;
                }

                ctx.fillRect(seg.x * cs + 1 + offset, seg.y * cs + 1 + offset, size - 2, size - 2);

                // Eyes for head
                if (i === 0) {
                    ctx.fillStyle = '#2c3e50';
                    const eyeSize = size / 5;
                    ctx.fillRect(seg.x * cs + cs / 4 + offset, seg.y * cs + cs / 4 + offset, eyeSize, eyeSize);
                    ctx.fillRect(seg.x * cs + cs * 3 / 4 - eyeSize + offset, seg.y * cs + cs / 4 + offset, eyeSize, eyeSize);
                }
                // Letters for body
                else if (seg.char) {
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = `bold ${Math.floor(cs * 0.7)}px Fredoka`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(seg.char, seg.x * cs + cs / 2, seg.y * cs + cs / 2 + 2);
                }
            });

            // Items
            if (targetLetterItem) drawItem(targetLetterItem, '#f1c40f');
            decoyItems.forEach(d => drawItem(d, '#e74c3c'));
        }

        function drawItem(item, color) {
            const cs = canvas.cellSize;
            const x = item.x * cs + cs / 2;
            const y = item.y * cs + cs / 2;

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, cs / 2 - 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#2c3e50';
            ctx.font = `bold ${Math.floor(cs * 0.7)}px Fredoka`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(item.char, x, y + 2);
        }

        function handleCrash() {
            lives--;
            updateHUD();

            // Shake effect?
            canvas.style.transform = "translate(5px, 5px)";
            setTimeout(() => canvas.style.transform = "none", 100);

            if (lives <= 0) {
                clearInterval(gameLoop);
                document.getElementById('gameOverModal').style.display = 'flex';
            } else {
                // Reset position but keep snake length/segments?
                // If we reset position, we have to reconstruct the snake body at the new position.
                // Or we just respawn the head and drag the tail?
                // Easier to just reset to Head-only but keep the score/progress?
                // User said "keep that numbers going".
                // If I crash, do I lose my collected letters?
                // Usually yes.
                // But "don't end the live" implies leniency.
                // Let's keep the collected letters if possible.
                // But physically moving a long snake to center is hard (where do segments go?).
                // I'll reset to Head-only and reset collectedCount?
                // Or maybe just bounce back?
                // Let's just reset to Head-only but keep the score.
                // But then the visual history is lost.
                // Let's try to keep the history:
                // We can't easily move the whole snake.
                // I will reset to Head-only and reset collectedCount to 0 for the current name.
                // It's a penalty.

                clearInterval(gameLoop);
                setTimeout(() => {
                    const startX = Math.floor(tileCountX / 2);
                    const startY = Math.floor(tileCountY / 2);
                    snake = [{ x: startX, y: startY, char: '', color: 'head' }];
                    velocity = { x: 0, y: -1 };
                    nextVelocity = { x: 0, y: -1 };

                    // Reset progress on this name
                    collectedCount = 0;
                    spawnTarget();
                    updateHUD();

                    gameLoop = setInterval(update, 350);
                }, 1000);
            }
        }

        function handleInput(dir) {
            if (dir === 'UP' && velocity.y === 0) nextVelocity = { x: 0, y: -1 };
            if (dir === 'DOWN' && velocity.y === 0) nextVelocity = { x: 0, y: 1 };
            if (dir === 'LEFT' && velocity.x === 0) nextVelocity = { x: -1, y: 0 };
            if (dir === 'RIGHT' && velocity.x === 0) nextVelocity = { x: 1, y: 0 };
        }

        function handleKeyInput(e) {
            switch (e.key) {
                case 'ArrowUp': handleInput('UP'); break;
                case 'ArrowDown': handleInput('DOWN'); break;
                case 'ArrowLeft': handleInput('LEFT'); break;
                case 'ArrowRight': handleInput('RIGHT'); break;
            }
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'collect') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(523.25, now);
                osc.frequency.exponentialRampToValueAtTime(1046.5, now + 0.1);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'crash') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.3);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'win') {
                [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                    const o = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    o.connect(g);
                    g.connect(audioCtx.destination);
                    o.frequency.value = freq;
                    g.gain.setValueAtTime(0.1, now + i * 0.1);
                    g.gain.linearRampToValueAtTime(0, now + i * 0.1 + 0.2);
                    o.start(now + i * 0.1);
                    o.stop(now + i * 0.1 + 0.2);
                });
            }
        }

        const melody = [
            { f: 659, d: 0.125 }, { f: 587, d: 0.125 }, { f: 494, d: 0.125 }, { f: 523, d: 0.125 },
            { f: 587, d: 0.25 }, { f: 523, d: 0.25 }, { f: 440, d: 0.25 }, { f: 440, d: 0.125 },
            { f: 523, d: 0.125 }, { f: 659, d: 0.25 }, { f: 587, d: 0.125 }, { f: 523, d: 0.125 },
            { f: 494, d: 0.375 }, { f: 494, d: 0.125 }, { f: 523, d: 0.125 }, { f: 587, d: 0.25 },
            { f: 659, d: 0.25 }, { f: 523, d: 0.25 }, { f: 440, d: 0.25 }, { f: 440, d: 0.25 }
        ];
        let noteIndex = 0;

        function playMusic() {
            if (musicNode) return;
            function schedule() {
                if (!gameLoop && document.getElementById('gameScreen').style.display === 'none') {
                    musicNode = null;
                    return;
                }
                const note = melody[noteIndex];
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'square';
                osc.frequency.value = note.f;
                const now = audioCtx.currentTime;
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.linearRampToValueAtTime(0, now + note.d * 0.9);
                osc.start(now);
                osc.stop(now + note.d);
                noteIndex = (noteIndex + 1) % melody.length;
                musicNode = setTimeout(schedule, note.d * 1000);
            }
            schedule();
        }

        function stopMusic() {
            if (musicNode) {
                clearTimeout(musicNode);
                musicNode = null;
            }
        }



        function handleWin() {
            clearInterval(gameLoop);
            playSound('win');
            document.getElementById('victoryMsg').innerText = `You spelled ${currentName}!`;
            document.getElementById('victoryModal').style.display = 'flex';
        }

        function updateHUD() {
            document.getElementById('scoreDisplay').innerText = score;
            document.getElementById('livesDisplay').innerText = "‚ù§Ô∏è".repeat(lives);

            const wordContainer = document.getElementById('wordDisplay');
            wordContainer.innerHTML = '';
            for (let i = 0; i < currentName.length; i++) {
                const span = document.createElement('span');
                span.className = 'letter-slot ' + (i < collectedCount ? 'collected' : '');
                span.innerText = currentName[i];
                wordContainer.appendChild(span);
            }
        }

        function nextLevel() {
            currentNameIndex++;
            if (currentNameIndex >= names.length) {
                currentNameIndex = 0;
                alert("You finished all names! Starting over!");
            }
            startLevel();
        }

        function retryLevel() {
            lives = 3;
            score = 0;
            document.getElementById('gameOverModal').style.display = 'none';
            startLevel();
        }

        init();
    </script>
</body>

</html>